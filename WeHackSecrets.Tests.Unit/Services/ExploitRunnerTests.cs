using Moq;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using WeHackSecrets.Services;
using WeHackSecrets.Services.Exploits;
using WeHackSecrets.Services.Models;
using Xunit;

namespace WeHackSecrets.Tests.Unit.Services
{
    public class ExploitRunnerTests
    {
        [Fact]
        public void ConstructorWithExploitThrowsArgumentException()
        {
            var ex = Assert.Throws<ArgumentNullException>(() =>
                new ExploitRunner(1, null)
            );

            Assert.Contains("exploit", ex.Message);
        }

        [Fact]
        public void CurrentStateBeforeStartIsNotStarted()
        {
            var exploit = new Mock<IExploit>();

            var sut = new ExploitRunner(1, exploit.Object);

            var result = sut.CurrentState;

            Assert.Equal(ExploitStatus.NotStarted, result.Exploited);
        }


        [Fact]
        public void CurrentStateWhenRunsThroughExpectedStates()
        {
            var exploitFinished = false;
            var exploit = new Mock<IExploit>();
            exploit.Setup(x => x.Exploit()).Callback(() =>
            {
                while (!exploitFinished)
                {
                    Thread.Sleep(10);
                }
            });
            exploit.Setup(x => x.Successful).Returns(true);
            exploit.Setup(x => x.SecretValue).Returns("Secret12345");

            var sut = new ExploitRunner(1, exploit.Object);

            Assert.Equal(ExploitStatus.NotStarted, sut.CurrentState.Exploited);
            sut.Start();
            Assert.Equal(ExploitStatus.Running, sut.CurrentState.Exploited);

            // Allow time for the exploit to complete
            exploitFinished = true;
            Thread.Sleep(20);
            Assert.Equal(ExploitStatus.Successful, sut.CurrentState.Exploited);
        }

        [Fact]
        public void CurrentStateWhenHasFailure()
        {
            var exploit = new Mock<IExploit>();
            exploit.Setup(x => x.Exploit()).Callback(() =>
            {
                throw new ArgumentException("Broken!!!");
            });

            var sut = new ExploitRunner(1, exploit.Object);
            sut.Start();

            Thread.Sleep(20);
            Assert.Equal(ExploitStatus.Failed, sut.CurrentState.Exploited);
        }


        [Fact]
        public void CurrentStateWhenExploitIsSuccessful()
        {
            var exploit = new Mock<IExploit>();
            exploit.Setup(x => x.Successful).Returns(true);
            exploit.Setup(x => x.SecretValue).Returns("Secret12345");

            var sut = new ExploitRunner(1, exploit.Object);
            sut.Start();

            Thread.Sleep(20);
            var result = sut.CurrentState;
            Assert.Equal(ExploitStatus.Successful, result.Exploited);
            Assert.Equal("Secret12345", result.Value);
        }

        [Fact]
        public void CurrentStateWhenExploitFails()
        {
            var exploit = new Mock<IExploit>();
            exploit.Setup(x => x.Successful).Returns(false);

            var sut = new ExploitRunner(1, exploit.Object);
            sut.Start();

            Thread.Sleep(20);
            var result = sut.CurrentState;
            Assert.Equal(ExploitStatus.Failed, result.Exploited);
            Assert.Null(result.Value);
        }

    }
}
