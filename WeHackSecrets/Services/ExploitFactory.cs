using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using WeHackSecrets.Services.Actions;
using WeHackSecrets.Services.Exploits.BrokenAccessControl;
using WeHackSecrets.Services.Exploits.Injection.Sql;
using WeHackSecrets.Services.Exploits.WorkInProgress;

namespace WeHackSecrets.Services
{
    public class ExploitFactory
    {
        private IServiceProvider _serviceProvider;
        private string _hackerUser;
        private string _targetUser;
        private string _targetKey;

        public ExploitFactory(IServiceProvider serviceProvider,
                                string hackerUser,
                                string targetUser,
                                string targetKey)
        {
            if (serviceProvider == null) throw new ArgumentNullException("serviceProvider");
            if (hackerUser == null) throw new ArgumentNullException("hackerUser");
            if (targetUser == null) throw new ArgumentNullException("targetUser");
            if (targetKey == null) throw new ArgumentNullException("targetKey");

            _serviceProvider = serviceProvider;
            _hackerUser = hackerUser;
            _targetUser = targetUser;
            _targetKey = targetKey;
        }

        public IExploitRunner[] GetExploits()
        {
            return new IExploitRunner[]
            {
                GetSqlInjectionCopySecretOnSecretSave(1),
                GetEnumerateSecretShare(2, 4000, 100)
            };
        }

        private IExploitRunner GetSqlInjectionCopySecretOnSecretSave(int id)
        {
            var sharedHttpClient = _serviceProvider.GetRequiredService<IHttpClientProxy>();
            var exploit = new CopySecretOnSecretSave(_hackerUser,
                                                            _targetUser,
                                                            _targetKey,
                                                            new LoginAction(sharedHttpClient, new AntiForgeryAction(sharedHttpClient)),
                                                            new CreateSecretAction(sharedHttpClient, new AntiForgeryAction(sharedHttpClient)),
                                                            new SecretsList(sharedHttpClient));

            return new ExploitRunner(id, exploit);
        }

        private IExploitRunner GetEnumerateSecretShare(int id, int seed, int threads)
        {
            var sharedHttpClient = _serviceProvider.GetRequiredService<IHttpClientProxy>();

            var sharesList = new List<ISecretsList>();
            for (int i = 0; i < threads; i++)
            {
                sharesList.Add(new SecretShare(sharedHttpClient, seed + i));
            }

            var exploit = new EnumerateSecretShare(_targetKey, sharesList);

            return new ExploitRunner(id, exploit);
        }

        private IExploitRunner GetLoginBruteForce(int id)
        {
            throw new NotImplementedException("Unable to get running quick enough to be usable");
           
            var poolCount = 1000;
            var loginPool = new LoginAction[poolCount];

            for (int i = 0; i < poolCount; i++)
            {
                var sharedHttpClient = _serviceProvider.GetRequiredService<IHttpClientProxy>();
                loginPool[i] = new LoginAction(sharedHttpClient, new AntiForgeryAction(sharedHttpClient));
            }

            var exploit = new LoginBruteForce(loginPool);
            return new ExploitRunner(id, exploit);
        }
    }
}
